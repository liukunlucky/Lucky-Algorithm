import { router } from '@kit.ArkUI';
import promptAction from '@ohos.promptAction';
import { UserProgressDao } from '../dao/UserProgressDao';
import { ProblemCategory, ProblemModel } from '../model/ProblemModel';
import { ProblemMockData } from '../mock/ProblemMockData';

interface CategoryStats {
  category: ProblemCategory;
  categoryName: string;
  solved: number;
  total: number;
  accuracy: number;
  color: string;
  icon: Resource;
  problems?: ProblemModel[];
  completedProblems?: ProblemModel[];
  expanded?: boolean;
}

interface DifficultyStats {
  difficulty: string;
  solved: number;
  total: number;
  color: string;
}

interface CategoryConfig {
  category: ProblemCategory;
  name: string;
  icon: Resource;
  color: string;
}

@Entry
@Component
struct TotalSolvedPage {
  @State totalSolved: number = 0;
  @State totalProblems: number = 0;
  @State categoryStats: CategoryStats[] = [];
  @State difficultyStats: DifficultyStats[] = [];
  @State averageAccuracy: number = 0;
  @State selectedTab: number = 0; // 0: åˆ†ç±»ç»Ÿè®¡, 1: éš¾åº¦ç»Ÿè®¡
  @State isLoading: boolean = true;
  @State expandedCategories: Set<string> = new Set();

  private userProgressDao: UserProgressDao = new UserProgressDao();

  aboutToAppear(): void {
    this.loadSolvedStats();
  }

  build() {
    Column() {
      // é¡¶éƒ¨å¯¼èˆªæ 
      this.buildHeader()

      if (this.isLoading) {
        this.buildLoadingState()
      } else {
        // å†…å®¹åŒºåŸŸ
        Column({ space: 16 }) {
          // æ€»ä½“ç»Ÿè®¡å¡ç‰‡
          this.buildOverviewCard()

          // Tabåˆ‡æ¢
          this.buildTabBar()

          // å†…å®¹åŒºåŸŸ
          if (this.selectedTab === 0) {
            this.buildCategoryStats()
          } else {
            this.buildDifficultyStats()
          }
        }
        .width('100%')
        .layoutWeight(1)
        .padding(16)
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#f5f5f5')
  }

  @Builder
  buildHeader() {
    Row() {
      Button() {
        Image($r('app.media.icon_back'))
          .width(24)
          .height(24)
          .fillColor('#333333')
      }
      .width(32)
      .backgroundColor('transparent')
      .onClick(() => {
        router.back();
      })

      Text('æ€»æ”»å…‹é¢˜æ•°')
        .fontSize(18)
        .fontWeight(FontWeight.Bold)
        .fontColor('#333333')
        .layoutWeight(1)
        .textAlign(TextAlign.Center)

      Blank().width(32)
    }
    .width('100%')
    .height(56)
    .padding({ left: 16, right: 16 })
    .backgroundColor('#ffffff')
    .shadow({
      radius: 2,
      color: '#00000010',
      offsetX: 0,
      offsetY: 1
    })
  }

  @Builder
  buildLoadingState() {
    Column({ space: 16 }) {
      LoadingProgress()
        .width(40)
        .height(40)
        .color('#F34F40')

      Text('æ­£åœ¨åŠ è½½ç»Ÿè®¡æ•°æ®...')
        .fontSize(14)
        .fontColor('#666666')
    }
    .width('100%')
    .layoutWeight(1)
    .justifyContent(FlexAlign.Center)
    .alignItems(HorizontalAlign.Center)
  }

  @Builder
  buildOverviewCard() {
    Column({ space: 20 }) {
      // ä¸»è¦æ•°æ®
      Row() {
        Column({ space: 8 }) {
          Text(this.totalSolved.toString())
            .fontSize(32)
            .fontWeight(FontWeight.Bold)
            .fontColor('#F34F40')

          Text('å·²æ”»å…‹é¢˜ç›®')
            .fontSize(14)
            .fontColor('#666666')
        }
        .alignItems(HorizontalAlign.Center)
        .layoutWeight(1)

        Divider()
          .vertical(true)
          .height(60)
          .strokeWidth(1)
          .color('#E5E7EB')

        Column({ space: 8 }) {
          Text(this.totalProblems.toString())
            .fontSize(32)
            .fontWeight(FontWeight.Bold)
            .fontColor('#52c41a')

          Text('é¢˜åº“æ€»æ•°')
            .fontSize(14)
            .fontColor('#666666')
        }
        .alignItems(HorizontalAlign.Center)
        .layoutWeight(1)
      }
      .width('100%')

      // è¿›åº¦æ¡
      Column({ space: 8 }) {
        Row() {
          Text('å®Œæˆè¿›åº¦')
            .fontSize(14)
            .fontColor('#333333')
            .layoutWeight(1)

          Text(`${Math.round((this.totalSolved / this.totalProblems) * 100)}%`)
            .fontSize(14)
            .fontWeight(FontWeight.Medium)
            .fontColor('#F34F40')
        }
        .width('100%')

        Progress({
          value: this.totalSolved,
          total: this.totalProblems,
          type: ProgressType.Linear
        })
          .width('100%')
          .height(8)
          .color('#F34F40')
          .backgroundColor('#E5E7EB')
          .borderRadius(4)
      }
      .width('100%')

      // æ­£ç¡®ç‡
      Row() {
        Column({ space: 4 }) {
          Text(`${this.averageAccuracy}%`)
            .fontSize(20)
            .fontWeight(FontWeight.Bold)
            .fontColor('#52c41a')

          Text('å¹³å‡æ­£ç¡®ç‡')
            .fontSize(12)
            .fontColor('#666666')
        }
        .alignItems(HorizontalAlign.Center)
        .layoutWeight(1)

        Column({ space: 4 }) {
          Text(this.getStudyLevel())
            .fontSize(20)
            .fontWeight(FontWeight.Bold)
            .fontColor('#722ed1')

          Text('å­¦ä¹ ç­‰çº§')
            .fontSize(12)
            .fontColor('#666666')
        }
        .alignItems(HorizontalAlign.Center)
        .layoutWeight(1)
      }
      .width('100%')
    }
    .width('100%')
    .padding(20)
    .backgroundColor('#ffffff')
    .borderRadius(12)
    .shadow({
      radius: 2,
      color: '#00000008',
      offsetX: 0,
      offsetY: 1
    })
  }

  @Builder
  buildTabBar() {
    Row() {
      this.buildTabItem('åˆ†ç±»ç»Ÿè®¡', 0)
      this.buildTabItem('éš¾åº¦ç»Ÿè®¡', 1)
    }
    .height(44)
    .backgroundColor('#ffffff')
    .borderRadius(22)
    .shadow({
      radius: 2,
      color: '#00000008',
      offsetX: 0,
      offsetY: 1
    })
  }

  @Builder
  buildTabItem(title: string, index: number) {
    Text(title)
      .fontSize(14)
      .fontColor(this.selectedTab === index ? '#ffffff' : '#666666')
      .fontWeight(this.selectedTab === index ? FontWeight.Medium : FontWeight.Normal)
      .textAlign(TextAlign.Center)
      .layoutWeight(1)
      .height('100%')
      .backgroundColor(this.selectedTab === index ? '#F34F40' : 'transparent')
      .borderRadius(22)
      .onClick(() => {
        this.selectedTab = index;
      })
  }

  @Builder
  buildCategoryStats() {
    List({ space: 12 }) {
      ForEach(this.categoryStats, (stats: CategoryStats) => {
        ListItem() {
          this.buildCategoryItem(stats)
        }
      })
    }
    .width('100%')
    .layoutWeight(1)
    .scrollBar(BarState.Off)
    .edgeEffect(EdgeEffect.Spring)
  }

  @Builder
  buildCategoryItem(stats: CategoryStats) {
    Column() {
      // ä¸»è¦ä¿¡æ¯è¡Œ
      Row({ space: 16 }) {
        // ä¿¡æ¯
        Column({ space: 4 }) {
          Row() {
            Text(stats.categoryName)
              .fontSize(16)
              .fontWeight(FontWeight.Medium)
              .fontColor('#333333')
              .layoutWeight(1)

            Text(`${stats.solved}/${stats.total}`)
              .fontSize(14)
              .fontColor('#666666')
          }
          .width('100%')

          Row() {
            Progress({
              value: stats.solved,
              total: stats.total,
              type: ProgressType.Linear
            })
              .width(120)
              .height(4)
              .color(stats.color)
              .backgroundColor('#E5E7EB')
              .borderRadius(2)

            Blank()

            Text(`${stats.accuracy}%`)
              .fontSize(12)
              .fontColor(stats.color)
              .fontWeight(FontWeight.Medium)
          }
          .width('100%')
          .alignItems(VerticalAlign.Center)

          Row() {
            Button() {
              Image($r('app.media.icon_down_arrow'))
                .width(16)
                .height(16)
                .rotate({angle: this.expandedCategories.has(stats.category)? 180: 0})
                .fillColor('#666666')
                .animation({
                  duration: 300,
                  curve: Curve.EaseInOut
                })
            }
            .width(32)
            .height(32)
            .align(Alignment.End)
            .layoutWeight(1)
            .backgroundColor('transparent')
            .onClick(() => {
              this.toggleCategoryExpand(stats.category);
            })
          }
          .width('100%')
          .visibility(stats.solved > 0?Visibility.Visible: Visibility.None)
          .alignItems(VerticalAlign.Center)
        }
        .layoutWeight(1)
      }
      .width('100%')

      // å±•å¼€çš„é¢˜ç›®åˆ—è¡¨ - åªæ˜¾ç¤ºå·²æ”»å…‹çš„é¢˜ç›®
      if (this.expandedCategories.has(stats.category) && stats.solved > 0) {
        this.buildCompletedProblemsList(stats)
      }
    }
    .width('100%')
    .padding(16)
    .backgroundColor('#ffffff')
    .borderRadius(12)
    .shadow({
      radius: 2,
      color: '#00000008',
      offsetX: 0,
      offsetY: 1
    })
  }

  @Builder
  buildCompletedProblemsList(stats: CategoryStats) {
    Column({ space: 8 }) {
      Divider()
        .strokeWidth(1)
        .color('#E5E7EB')
        .margin({ top: 12, bottom: 8 })

      // æ˜¾ç¤ºå·²æ”»å…‹é¢˜ç›®æ•°é‡
      Text(`å·²æ”»å…‹ ${stats.solved} é“é¢˜ç›®`)
        .fontSize(14)
        .fontColor('#666666')
        .margin({ bottom: 8 })

      // åŠ¨æ€åŠ è½½å·²æ”»å…‹çš„é¢˜ç›®åˆ—è¡¨
      if (stats.completedProblems && stats.completedProblems.length > 0) {
        ForEach(stats.completedProblems, (problem: ProblemModel) => {
          this.buildProblemItem(problem)
        })
      } else {
        Text('æ­£åœ¨åŠ è½½å·²æ”»å…‹é¢˜ç›®...')
          .fontSize(12)
          .fontColor('#999999')
          .margin({ top: 8, bottom: 8 })
      }
    }
    .width('100%')
    .animation({
      duration: 300,
      curve: Curve.EaseInOut
    })
  }

  @Builder
  buildProblemItem(problem: ProblemModel) {
    Row({ space: 12 }) {
      // éš¾åº¦æ ‡è¯†
      Text(problem.getDifficultyText())
        .fontSize(12)
        .fontColor('#ffffff')
        .backgroundColor(problem.getDifficultyColor())
        .padding({ left: 8, right: 8, top: 2, bottom: 2 })
        .borderRadius(10)

      // é¢˜ç›®æ ‡é¢˜
      Text(problem.title)
        .fontSize(14)
        .fontColor('#333333')
        .layoutWeight(1)
        .maxLines(1)
        .textOverflow({ overflow: TextOverflow.Ellipsis })

      // æŸ¥çœ‹é¢˜ç›®æŒ‰é’®
      Text('æŸ¥çœ‹é¢˜ç›®')
        .fontSize(12)
        .fontColor('#F34F40')
        .onClick(() => {
          this.navigateToProblemDetail(problem.id);
        })
    }
    .width('100%')
    .padding({ left: 8, right: 8, top: 8, bottom: 8 })
    .backgroundColor('#f8f9fa')
    .borderRadius(8)
  }

  @Builder
  buildDifficultyStats() {
    Column({ space: 12 }) {
      ForEach(this.difficultyStats, (stats: DifficultyStats) => {
        this.buildDifficultyItem(stats)
      }, (stats: DifficultyStats) => stats.difficulty.toString())
    }
    .width('100%')
    .layoutWeight(1)
  }

  @Builder
  buildDifficultyItem(stats: DifficultyStats) {
    Row({ space: 16 }) {
      // éš¾åº¦æ ‡è¯†
      Circle()
        .width(12)
        .height(12)
        .fill(stats.color)

      // ä¿¡æ¯
      Column({ space: 8 }) {
        Row() {
          Text(stats.difficulty)
            .fontSize(16)
            .fontWeight(FontWeight.Medium)
            .fontColor('#333333')
            .layoutWeight(1)

          Text(`${stats.solved}/${stats.total}`)
            .fontSize(14)
            .fontColor('#666666')
        }
        .width('100%')

        Progress({
          value: stats.solved,
          total: stats.total,
          type: ProgressType.Linear
        })
          .width('100%')
          .height(8)
          .color(stats.color)
          .backgroundColor('#E5E7EB')
          .borderRadius(4)

        Text(`å®Œæˆç‡: ${Math.round((stats.solved / stats.total) * 100)}%`)
          .fontSize(12)
          .fontColor('#666666')
      }
      .layoutWeight(1)
    }
    .width('100%')
    .padding(16)
    .backgroundColor('#ffffff')
    .borderRadius(12)
    .shadow({
      radius: 2,
      color: '#00000008',
      offsetX: 0,
      offsetY: 1
    })
  }

  // åŠ è½½æ”»å…‹é¢˜æ•°ç»Ÿè®¡
  private async loadSolvedStats(): Promise<void> {
    try {
      this.isLoading = true;
      console.info('ğŸ“Š å¼€å§‹åŠ è½½æ”»å…‹é¢˜æ•°ç»Ÿè®¡');

      // è·å–æ€»æ”»å…‹é¢˜æ•°
      this.totalSolved = await this.userProgressDao.getCompletedCount();

      // è·å–é¢˜åº“æ€»æ•°
      const allProblems = ProblemMockData.getAllProblems();
      this.totalProblems = allProblems.length;

      // è·å–å¹³å‡æ­£ç¡®ç‡
      const statistics = await this.userProgressDao.getStatistics();
      this.averageAccuracy = statistics.overallAccuracy;

      // åŠ è½½åˆ†ç±»ç»Ÿè®¡
      await this.loadCategoryStats();

      // åŠ è½½éš¾åº¦ç»Ÿè®¡
      await this.loadDifficultyStats();

      console.info('âœ… æ”»å…‹é¢˜æ•°ç»Ÿè®¡åŠ è½½å®Œæˆ');
    } catch (error) {
      console.error('âŒ åŠ è½½æ”»å…‹é¢˜æ•°ç»Ÿè®¡å¤±è´¥:', error);
      promptAction.showToast({
        message: 'åŠ è½½æ•°æ®å¤±è´¥ï¼Œè¯·é‡è¯•',
        duration: 2000
      });
    } finally {
      this.isLoading = false;
    }
  }

  // åŠ è½½åˆ†ç±»ç»Ÿè®¡
  private async loadCategoryStats(): Promise<void> {
    const categoryConfigs: CategoryConfig[] = [
      { category: ProblemCategory.ARRAY, name: 'æ•°ç»„', icon: $r('app.media.chart_icon'), color: '#1890ff' },
      { category: ProblemCategory.STRING, name: 'å­—ç¬¦ä¸²', icon: $r('app.media.note_icon'), color: '#52c41a' },
      { category: ProblemCategory.LINKED_LIST, name: 'é“¾è¡¨', icon: $r('app.media.book_icon'), color: '#fa8c16' },
      { category: ProblemCategory.BINARY_TREE, name: 'äºŒå‰æ ‘', icon: $r('app.media.book_icon'), color: '#13c2c2' },
      { category: ProblemCategory.TWO_POINTERS, name: 'åŒæŒ‡é’ˆ', icon: $r('app.media.target_icon'), color: '#722ed1' },
      { category: ProblemCategory.BINARY_SEARCH, name: 'äºŒåˆ†æŸ¥æ‰¾', icon: $r('app.media.search_icon'), color: '#eb2f96' },
      { category: ProblemCategory.MATH, name: 'æ•°å­¦', icon: $r('app.media.computer_icon'), color: '#f5222d' },
      { category: ProblemCategory.DYNAMIC_PROGRAMMING, name: 'åŠ¨æ€è§„åˆ’', icon: $r('app.media.star_icon'), color: '#fa541c' },
      { category: ProblemCategory.STACK, name: 'æ ˆ', icon: $r('app.media.book_icon'), color: '#faad14' },
      { category: ProblemCategory.HASH_TABLE, name: 'å“ˆå¸Œè¡¨', icon: $r('app.media.computer_icon'), color: '#52c41a' },
      { category: ProblemCategory.BACKTRACKING, name: 'å›æº¯', icon: $r('app.media.star_icon'), color: '#722ed1' },
      { category: ProblemCategory.GREEDY, name: 'è´ªå¿ƒ', icon: $r('app.media.target_icon'), color: '#13c2c2' },
      { category: ProblemCategory.BIT_MANIPULATION, name: 'ä½è¿ç®—', icon: $r('app.media.computer_icon'), color: '#eb2f96' },
      { category: ProblemCategory.DESIGN, name: 'è®¾è®¡', icon: $r('app.media.computer_icon'), color: '#f5222d' },
      { category: ProblemCategory.DIVIDE_CONQUER, name: 'åˆ†æ²»', icon: $r('app.media.star_icon'), color: '#fa541c' },
      { category: ProblemCategory.SLIDING_WINDOW, name: 'æ»‘åŠ¨çª—å£', icon: $r('app.media.chart_icon'), color: '#faad14' },
      { category: ProblemCategory.PREFIX_SUM, name: 'å‰ç¼€å’Œ', icon: $r('app.media.chart_icon'), color: '#52c41a' },
      { category: ProblemCategory.MONOTONIC_STACK, name: 'å•è°ƒæ ˆ', icon: $r('app.media.chart_icon'), color: '#1890ff' },
      { category: ProblemCategory.TRIE, name: 'å­—å…¸æ ‘', icon: $r('app.media.book_icon'), color: '#fa8c16' },
      { category: ProblemCategory.GRAPH, name: 'å›¾', icon: $r('app.media.computer_icon'), color: '#13c2c2' },
      { category: ProblemCategory.SORT, name: 'æ’åº', icon: $r('app.media.star_icon'), color: '#722ed1' }
    ];

    const stats: CategoryStats[] = [];
    const allProblems = ProblemMockData.getAllProblems();

    for (const config of categoryConfigs) {
      const categoryProblems = allProblems.filter(p => p.category === config.category);
      const solved = await this.userProgressDao.getCompletedCountByCategory(config.category);
      const accuracy = await this.userProgressDao.getAccuracyByCategory(config.category);

      const categoryStats: CategoryStats = {
        category: config.category,
        categoryName: config.name,
        solved: solved,
        total: categoryProblems.length,
        accuracy: accuracy,
        color: config.color,
        icon: config.icon,
        problems: categoryProblems,
        expanded: false
      };
      stats.push(categoryStats);
    }

    this.categoryStats = stats.sort((a: CategoryStats, b: CategoryStats): number => b.solved - a.solved);
  }

  // åŠ è½½éš¾åº¦ç»Ÿè®¡
  private async loadDifficultyStats(): Promise<void> {
    const allProblems = ProblemMockData.getAllProblems();
    
    // æŒ‰éš¾åº¦åˆ†ç»„
    const easyProblems = allProblems.filter((p: ProblemModel): boolean => p.difficulty === 0);
    const mediumProblems = allProblems.filter((p: ProblemModel): boolean => p.difficulty === 1);
    const hardProblems = allProblems.filter((p: ProblemModel): boolean => p.difficulty === 2);

    const easySolved = await this.userProgressDao.getCompletedCountByDifficulty(0);
    const mediumSolved = await this.userProgressDao.getCompletedCountByDifficulty(1);
    const hardSolved = await this.userProgressDao.getCompletedCountByDifficulty(2);

    const easyDifficulty: DifficultyStats = {
      difficulty: 'ç®€å•',
      solved: easySolved,
      total: easyProblems.length,
      color: '#52c41a'
    };
    
    const mediumDifficulty: DifficultyStats = {
      difficulty: 'ä¸­ç­‰',
      solved: mediumSolved,
      total: mediumProblems.length,
      color: '#fa8c16'
    };
    
    const hardDifficulty: DifficultyStats = {
      difficulty: 'å›°éš¾',
      solved: hardSolved,
      total: hardProblems.length,
      color: '#f5222d'
    };
    
    this.difficultyStats = [easyDifficulty, mediumDifficulty, hardDifficulty];
  }

  // è·å–å­¦ä¹ ç­‰çº§
  private getStudyLevel(): string {
    const solved = this.totalSolved;
    if (solved < 10) return 'æ–°æ‰‹';
    if (solved < 30) return 'å…¥é—¨';
    if (solved < 60) return 'è¿›é˜¶';
    if (solved < 100) return 'ç†Ÿç»ƒ';
    if (solved < 200) return 'é«˜æ‰‹';
    return 'ä¸“å®¶';
  }

  // åˆ‡æ¢åˆ†ç±»å±•å¼€çŠ¶æ€
  private async toggleCategoryExpand(category: ProblemCategory): Promise<void> {
    if (this.expandedCategories.has(category)) {
      this.expandedCategories.delete(category);
    } else {
      this.expandedCategories.add(category);
      // å±•å¼€æ—¶åŠ è½½å·²æ”»å…‹çš„é¢˜ç›®
      await this.loadCompletedProblemsForCategory(category);
    }
    // è§¦å‘çŠ¶æ€æ›´æ–°
    this.expandedCategories = new Set(this.expandedCategories);
  }

  // åŠ è½½æŒ‡å®šåˆ†ç±»çš„å·²æ”»å…‹é¢˜ç›®
  private async loadCompletedProblemsForCategory(category: ProblemCategory): Promise<void> {
    try {
      // è·å–ç”¨æˆ·åœ¨è¯¥åˆ†ç±»ä¸‹å·²å®Œæˆçš„é¢˜ç›® ID åˆ—è¡¨
      const completedProblemIds = await this.userProgressDao.getCompletedProblemIdsByCategory(category);
      
      if (completedProblemIds.length > 0) {
        // ä» Mock æ•°æ®ä¸­è·å–å¯¹åº”çš„é¢˜ç›®ä¿¡æ¯
        const allProblems = ProblemMockData.getAllProblems();
        const completedProblems = allProblems.filter(problem => 
          completedProblemIds.includes(problem.id) && problem.category === category
        );
        
        // æ›´æ–°å¯¹åº”åˆ†ç±»çš„å·²æ”»å…‹é¢˜ç›®åˆ—è¡¨
        const categoryIndex = this.categoryStats.findIndex(stats => stats.category === category);
        if (categoryIndex !== -1) {
          this.categoryStats[categoryIndex].completedProblems = completedProblems;
        }
      }
    } catch (error) {
      console.error(`åŠ è½½åˆ†ç±» ${category} çš„å·²æ”»å…‹é¢˜ç›®å¤±è´¥:`, error);
    }
  }
  private navigateToProblemDetail(problemId: number): void {
    router.pushUrl({
      url: 'pages/ProblemDetailPage',
      params: {
        problemId: problemId
      }
    }).catch((error: Error) => {
      console.error('å¯¼èˆªå¤±è´¥:', error);
    });
  }

  // å¯¼èˆªåˆ°åˆ†ç±»è¯¦æƒ…
  private navigateToCategoryDetail(category: ProblemCategory): void {
    router.pushUrl({
      url: 'pages/CategoryDetailPage',
      params: {
        category: category
      }
    }).catch((error: Error) => {
      console.error('å¯¼èˆªå¤±è´¥:', error);
    });
  }
}