import relationalStore from '@ohos.data.relationalStore';
import { UserProgressModel, ProblemStatus } from '../model/UserProgressModel';
import { ProblemCategory } from '../model/ProblemModel';
import { DatabaseHelper } from '../database/DatabaseHelper';
import { ProblemMockData } from '../mock/ProblemMockData';
import { TimeUtils } from '../utils/TimeUtils';

interface UserStatistics {
  totalAttempted: number;
  totalCompleted: number;
  totalWrong: number;
  totalFavorites: number;
  overallAccuracy: number;
}

export class UserProgressDao {
  private dbHelper: DatabaseHelper;

  constructor() {
    this.dbHelper = DatabaseHelper.getInstance();
  }

  // è·å–ç”¨æˆ·å¯¹æŒ‡å®šé¢˜ç›®çš„è¿›åº¦
  async getUserProgress(problemId: number): Promise<UserProgressModel | null> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const sql = 'SELECT * FROM user_progress WHERE problem_id = ?';
    const result = await store.querySql(sql, [problemId]);

    if (result.rowCount > 0) {
      result.goToRow(0);
      return this.mapResultToProgress(result);
    }

    return null;
  }

  // è·å–æ‰€æœ‰ç”¨æˆ·è¿›åº¦
  async getAllUserProgress(): Promise<UserProgressModel[]> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const sql = 'SELECT * FROM user_progress ORDER BY problem_id';
    const result = await store.querySql(sql);
    const progressList: UserProgressModel[] = [];

    if (result.rowCount > 0) {
      for (let i = 0; i < result.rowCount; i++) {
        result.goToRow(i);
        const progress = this.mapResultToProgress(result);
        progressList.push(progress);
      }
    }

    return progressList;
  }

  // è·å–ç”¨æˆ·æ”¶è—çš„é¢˜ç›®IDåˆ—è¡¨ï¼ˆé€šè¿‡ç”¨æˆ·è¿›åº¦è®°å½•ï¼‰
  async getFavoriteProblems(): Promise<UserProgressModel[]> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const sql = 'SELECT * FROM user_progress WHERE is_favorite = 1 ORDER BY last_attempted DESC';
    const result = await store.querySql(sql);
    const progressList: UserProgressModel[] = [];

    if (result.rowCount > 0) {
      for (let i = 0; i < result.rowCount; i++) {
        result.goToRow(i);
        const progress = this.mapResultToProgress(result);
        progressList.push(progress);
      }
    }

    return progressList;
  }

  // è·å–é”™é¢˜
  async getWrongProblems(): Promise<UserProgressModel[]> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const sql = 'SELECT * FROM user_progress WHERE status = ? ORDER BY last_attempted DESC';
    const result = await store.querySql(sql, [ProblemStatus.WRONG]);
    const progressList: UserProgressModel[] = [];

    if (result.rowCount > 0) {
      for (let i = 0; i < result.rowCount; i++) {
        result.goToRow(i);
        const progress = this.mapResultToProgress(result);
        progressList.push(progress);
      }
    }

    return progressList;
  }

  // è·å–å·²å®Œæˆçš„é¢˜ç›®
  async getCompletedProblems(): Promise<UserProgressModel[]> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const sql = 'SELECT * FROM user_progress WHERE status = ? ORDER BY last_attempted DESC';
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED]);
    const progressList: UserProgressModel[] = [];

    if (result.rowCount > 0) {
      for (let i = 0; i < result.rowCount; i++) {
        result.goToRow(i);
        const progress = this.mapResultToProgress(result);
        progressList.push(progress);
      }
    }

    return progressList;
  }

  // ä¿å­˜æˆ–æ›´æ–°ç”¨æˆ·è¿›åº¦
  async saveUserProgress(progress: UserProgressModel): Promise<void> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const existingProgress = await this.getUserProgress(progress.problemId);

    if (existingProgress) {
      // æ›´æ–°ç°æœ‰è®°å½•
      const sql = `
        UPDATE user_progress 
        SET status = ?, is_favorite = ?, last_attempted = ?, attempt_count = ?, success_count = ?
        WHERE problem_id = ?
      `;
      await store.executeSql(sql, [
        progress.status,
        progress.isFavorite ? 1 : 0,
        progress.lastAttempted,
        progress.attemptCount,
        progress.successCount,
        progress.problemId
      ]);
    } else {
      // æ’å…¥æ–°è®°å½•
      const sql = `
        INSERT INTO user_progress (problem_id, status, is_favorite, last_attempted, attempt_count, success_count)
        VALUES (?, ?, ?, ?, ?, ?)
      `;
      await store.executeSql(sql, [
        progress.problemId,
        progress.status,
        progress.isFavorite ? 1 : 0,
        progress.lastAttempted,
        progress.attemptCount,
        progress.successCount
      ]);
    }
  }

  // æ›´æ–°é¢˜ç›®çŠ¶æ€
  async updateProblemStatus(problemId: number, status: ProblemStatus, isSuccess: boolean = false): Promise<void> {
    let progress = await this.getUserProgress(problemId);
    
    if (!progress) {
      progress = new UserProgressModel();
      progress.problemId = problemId;
    }

    progress.recordAttempt(isSuccess);
    progress.status = status;
    
    await this.saveUserProgress(progress);
  }

  // åˆ‡æ¢æ”¶è—çŠ¶æ€
  async toggleFavorite(problemId: number): Promise<boolean> {
    let progress = await this.getUserProgress(problemId);
    
    if (!progress) {
      progress = new UserProgressModel();
      progress.problemId = problemId;
    }

    progress.toggleFavorite();
    await this.saveUserProgress(progress);
    
    return progress.isFavorite;
  }

  // æ¸…ç†æ‰€æœ‰æ”¶è—è®°å½•ï¼ˆç”¨äºé‡ç½®æ•°æ®ï¼‰
  async clearAllFavorites(): Promise<void> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const sql = 'UPDATE user_progress SET is_favorite = 0 WHERE is_favorite = 1';
    await store.executeSql(sql);
    console.log('All favorite records cleared');
  }

  // åˆ é™¤é”™é¢˜è®°å½•
  async deleteWrongProblem(problemId: number): Promise<void> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    // åˆ é™¤ç”¨æˆ·è¿›åº¦è®°å½•
    const sql = 'DELETE FROM user_progress WHERE problem_id = ? AND status = ?';
    await store.executeSql(sql, [problemId, ProblemStatus.WRONG]);
    console.log('Wrong problem record deleted for problemId:', problemId);
  }

  // è·å–å·²å®Œæˆé¢˜ç›®æ•°é‡ï¼ˆä»…ç­”å¯¹çš„é¢˜ç›®ï¼‰
  async getCompletedCount(): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const sql = 'SELECT COUNT(*) as count FROM user_progress WHERE status = ?';
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED]);
    
    if (result.rowCount > 0) {
      result.goToRow(0);
      return result.getLong(result.getColumnIndex('count'));
    }

    return 0;
  }

  // è·å–å­¦ä¹ è¿›åº¦æ•°é‡ï¼ˆåŒ…æ‹¬ç­”å¯¹å’Œç­”é”™çš„é¢˜ç›®ï¼‰
  async getStudyProgressCount(): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const sql = 'SELECT COUNT(*) as count FROM user_progress WHERE (status = ? OR status = ?)';
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED, ProblemStatus.WRONG]);
    
    if (result.rowCount > 0) {
      result.goToRow(0);
      return result.getLong(result.getColumnIndex('count'));
    }

    return 0;
  }

  // æ ¹æ®åˆ†ç±»è·å–å·²å®Œæˆé¢˜ç›®çš„IDåˆ—è¡¨
  async getCompletedProblemIdsByCategory(category: ProblemCategory): Promise<number[]> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    // ä»MockDataè·å–æŒ‡å®šåˆ†ç±»çš„æ‰€æœ‰é¢˜ç›®ID
    const allProblems = ProblemMockData.getAllProblems();
    const categoryProblems = allProblems.filter(p => p.category === category);
    const problemIds = categoryProblems.map(p => p.id);
    
    if (problemIds.length === 0) {
      return [];
    }

    // æŸ¥è¯¢è¿™äº›é¢˜ç›®IDä¸­å·²å®Œæˆçš„é¢˜ç›®ID
    const placeholders = problemIds.map(() => '?').join(',');
    const sql = `
      SELECT problem_id 
      FROM user_progress 
      WHERE status = ? AND problem_id IN (${placeholders})
      ORDER BY last_attempted DESC
    `;
    const params = [ProblemStatus.COMPLETED, ...problemIds];
    const result = await store.querySql(sql, params);
    
    const completedIds: number[] = [];
    if (result.rowCount > 0) {
      for (let i = 0; i < result.rowCount; i++) {
        result.goToRow(i);
        const problemId = result.getLong(result.getColumnIndex('problem_id'));
        completedIds.push(problemId);
      }
    }

    console.info(`[UserProgressDao] getCompletedProblemIdsByCategory - Category: ${category}, Completed IDs: ${completedIds}`);
    return completedIds;
  }
  async getCompletedCountByCategory(category: ProblemCategory): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    // ä»MockDataè·å–æŒ‡å®šåˆ†ç±»çš„æ‰€æœ‰é¢˜ç›®ID
    const allProblems = ProblemMockData.getAllProblems();
    const categoryProblems = allProblems.filter(p => p.category === category);
    const problemIds = categoryProblems.map(p => p.id);
    
    if (problemIds.length === 0) {
      return 0;
    }

    // æŸ¥è¯¢è¿™äº›é¢˜ç›®IDä¸­å·²å®Œæˆçš„æ•°é‡
    const placeholders = problemIds.map(() => '?').join(',');
    const sql = `
      SELECT COUNT(*) as count 
      FROM user_progress 
      WHERE status = ? AND problem_id IN (${placeholders})
    `;
    const params = [ProblemStatus.COMPLETED, ...problemIds];
    const result = await store.querySql(sql, params);
    
    if (result.rowCount > 0) {
      result.goToRow(0);
      const count = result.getLong(result.getColumnIndex('count'));
      console.info(`[UserProgressDao] getCompletedCountByCategory - Category: ${category}, Total problems: ${problemIds.length}, Completed: ${count}`);
      return count;
    }

    return 0;
  }

  // æ ¹æ®åˆ†ç±»è·å–å­¦ä¹ è¿›åº¦æ•°é‡ï¼ˆåŒ…æ‹¬ç­”å¯¹å’Œç­”é”™çš„é¢˜ç›®ï¼‰
  async getStudyProgressCountByCategory(category: ProblemCategory): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    // ä»MockDataè·å–æŒ‡å®šåˆ†ç±»çš„æ‰€æœ‰é¢˜ç›®ID
    const allProblems = ProblemMockData.getAllProblems();
    const categoryProblems = allProblems.filter(p => p.category === category);
    const problemIds = categoryProblems.map(p => p.id);
    
    if (problemIds.length === 0) {
      return 0;
    }

    // æŸ¥è¯¢è¿™äº›é¢˜ç›®IDä¸­å·²å­¦ä¹ çš„æ•°é‡ï¼ˆåŒ…æ‹¬ç­”å¯¹å’Œç­”é”™ï¼‰
    const placeholders = problemIds.map(() => '?').join(',');
    const sql = `
      SELECT COUNT(*) as count 
      FROM user_progress 
      WHERE (status = ? OR status = ?) AND problem_id IN (${placeholders})
    `;
    const params = [ProblemStatus.COMPLETED, ProblemStatus.WRONG, ...problemIds];
    const result = await store.querySql(sql, params);
    
    if (result.rowCount > 0) {
      result.goToRow(0);
      const count = result.getLong(result.getColumnIndex('count'));
      console.info(`[UserProgressDao] getStudyProgressCountByCategory - Category: ${category}, Total problems: ${problemIds.length}, Studied: ${count}`);
      return count;
    }

    return 0;
  }

  // æ ¹æ®åˆ†ç±»è·å–æ­£ç¡®ç‡
  async getAccuracyByCategory(category: ProblemCategory): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    // ä»MockDataè·å–æŒ‡å®šåˆ†ç±»çš„æ‰€æœ‰é¢˜ç›®ID
    const allProblems = ProblemMockData.getAllProblems();
    const categoryProblems = allProblems.filter(p => p.category === category);
    const problemIds = categoryProblems.map(p => p.id);
    
    if (problemIds.length === 0) {
      return 0;
    }

    // æŸ¥è¯¢è¿™äº›é¢˜ç›®IDçš„æˆåŠŸæ¬¡æ•°å’Œæ€»å°è¯•æ¬¡æ•°
    const placeholders = problemIds.map(() => '?').join(',');
    const sql = `
      SELECT 
        SUM(success_count) as total_success,
        SUM(attempt_count) as total_attempts
      FROM user_progress 
      WHERE problem_id IN (${placeholders}) AND (status = ? OR status = ?)
    `;
    const params = [...problemIds, ProblemStatus.COMPLETED, ProblemStatus.WRONG];
    const result = await store.querySql(sql, params);
    
    if (result.rowCount > 0) {
      result.goToRow(0);
      const totalSuccess = result.getLong(result.getColumnIndex('total_success'));
      const totalAttempts = result.getLong(result.getColumnIndex('total_attempts'));
      
      if (totalAttempts > 0) {
        const accuracy = Math.round((totalSuccess / totalAttempts) * 100);
        console.info(`[UserProgressDao] getAccuracyByCategory - Category: ${category}, Success: ${totalSuccess}, Attempts: ${totalAttempts}, Accuracy: ${accuracy}%`);
        return accuracy;
      }
    }

    return 0;
  }

  // è·å–ä»Šæ—¥å­¦ä¹ é¢˜ç›®æ•°é‡ï¼ˆåŒ…æ‹¬ç­”å¯¹å’Œç­”é”™ï¼‰
  async getTodayCompletedCount(): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const today = TimeUtils.getLocalDateString(); // YYYY-MM-DDæ ¼å¼
    const sql = 'SELECT COUNT(*) as count FROM user_progress WHERE (status = ? OR status = ?) AND DATE(last_attempted) = ?';
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED, ProblemStatus.WRONG, today]);

    if (result.rowCount > 0) {
      result.goToRow(0);
      return result.getLong(result.getColumnIndex('count'));
    }

    return 0;
  }

  // æ ¹æ®æ—¥æœŸè·å–å®Œæˆé¢˜ç›®æ•°é‡
  async getCompletedCountByDate(date: Date): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const dateStr = TimeUtils.getLocalDateString(date); // YYYY-MM-DDæ ¼å¼
    const sql = 'SELECT COUNT(*) as count FROM user_progress WHERE (status = ? OR status = ?) AND DATE(last_attempted) = ?';
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED, ProblemStatus.WRONG, dateStr]);

    if (result.rowCount > 0) {
      result.goToRow(0);
      return result.getLong(result.getColumnIndex('count'));
    }

    return 0;
  }

  // è·å–è¿ç»­å­¦ä¹ å¤©æ•°
  async getContinuousDays(): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    // è·å–æœ€è¿‘çš„å­¦ä¹ è®°å½•ï¼ŒæŒ‰æ—¥æœŸåˆ†ç»„ï¼ˆåŒ…æ‹¬ç­”å¯¹å’Œç­”é”™çš„é¢˜ç›®ï¼‰
    const sql = `
      SELECT DISTINCT DATE(last_attempted) as study_date 
      FROM user_progress 
      WHERE (status = ? OR status = ?) AND last_attempted IS NOT NULL 
      ORDER BY study_date DESC
    `;
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED, ProblemStatus.WRONG]);

    if (result.rowCount === 0) {
      return 0;
    }

    let continuousDays = 0;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // æ£€æŸ¥ä»Šå¤©æ˜¯å¦æœ‰å­¦ä¹ è®°å½•
    result.goToRow(0);
    const latestStudyDateStr = result.getString(result.getColumnIndex('study_date'));
    const latestStudyDate = new Date(latestStudyDateStr);
    latestStudyDate.setHours(0, 0, 0, 0);
    
    // å¦‚æœæœ€æ–°å­¦ä¹ æ—¥æœŸæ˜¯ä»Šå¤©ï¼Œä»ä»Šå¤©å¼€å§‹è®¡ç®—
    // å¦‚æœæœ€æ–°å­¦ä¹ æ—¥æœŸæ˜¯æ˜¨å¤©ï¼Œä»æ˜¨å¤©å¼€å§‹è®¡ç®—ï¼ˆä¿æŒè¿ç»­æ€§ï¼‰
    // å¦‚æœæœ€æ–°å­¦ä¹ æ—¥æœŸæ›´æ—©ï¼Œè¯´æ˜å·²ç»ä¸­æ–­ï¼Œè¿”å›0
    const daysDiff = Math.floor((today.getTime() - latestStudyDate.getTime()) / (1000 * 60 * 60 * 24));
    
    if (daysDiff > 1) {
      // ä¸­æ–­è¶…è¿‡1å¤©ï¼Œè¿ç»­å­¦ä¹ å¤©æ•°ä¸º0
      console.info(`ğŸ“… å­¦ä¹ å·²ä¸­æ–­ ${daysDiff} å¤©ï¼Œè¿ç»­å­¦ä¹ å¤©æ•°é‡ç½®ä¸º0`);
      return 0;
    }
    
    // ä»æœ€æ–°å­¦ä¹ æ—¥æœŸå¼€å§‹å‘å‰è®¡ç®—è¿ç»­å¤©æ•°
    let checkDate = new Date(latestStudyDate);
    
    for (let i = 0; i < result.rowCount; i++) {
      result.goToRow(i);
      const studyDateStr = result.getString(result.getColumnIndex('study_date'));
      const studyDate = new Date(studyDateStr);
      studyDate.setHours(0, 0, 0, 0);

      if (studyDate.getTime() === checkDate.getTime()) {
        continuousDays++;
        // æ£€æŸ¥å‰ä¸€å¤©
        checkDate.setDate(checkDate.getDate() - 1);
      } else {
        // æ—¥æœŸä¸è¿ç»­ï¼Œåœæ­¢è®¡ç®—
        break;
      }
    }

    console.info(`ğŸ“… è®¡ç®—è¿ç»­å­¦ä¹ å¤©æ•°: ${continuousDays} å¤©ï¼Œæœ€æ–°å­¦ä¹ æ—¥æœŸ: ${latestStudyDateStr}`);
    return continuousDays;
  }

  // è·å–ç»Ÿè®¡ä¿¡æ¯
  async getStatistics(): Promise<UserStatistics> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const sql = `
      SELECT 
        COUNT(*) as total_attempted,
        SUM(CASE WHEN status = ? THEN 1 ELSE 0 END) as total_completed,
        SUM(CASE WHEN status = ? THEN 1 ELSE 0 END) as total_wrong,
        SUM(CASE WHEN is_favorite = 1 THEN 1 ELSE 0 END) as total_favorites,
        SUM(success_count) as total_success,
        SUM(attempt_count) as total_attempts
      FROM user_progress
    `;
    
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED, ProblemStatus.WRONG]);
    
    if (result.rowCount > 0) {
      result.goToRow(0);
      const totalAttempted = result.getLong(result.getColumnIndex('total_attempted'));
      const totalCompleted = result.getLong(result.getColumnIndex('total_completed'));
      const totalWrong = result.getLong(result.getColumnIndex('total_wrong'));
      const totalFavorites = result.getLong(result.getColumnIndex('total_favorites'));
      const totalSuccess = result.getLong(result.getColumnIndex('total_success'));
      const totalAttempts = result.getLong(result.getColumnIndex('total_attempts'));
      
      const overallAccuracy = totalAttempts > 0 ? Math.round((totalSuccess / totalAttempts) * 100) : 0;
      
      const statistics: UserStatistics = {
        totalAttempted,
        totalCompleted,
        totalWrong,
        totalFavorites,
        overallAccuracy
      };
      return statistics;
    }

    const defaultStatistics: UserStatistics = {
      totalAttempted: 0,
      totalCompleted: 0,
      totalWrong: 0,
      totalFavorites: 0,
      overallAccuracy: 0
    };
    return defaultStatistics;
  }

  // å°†æŸ¥è¯¢ç»“æœæ˜ å°„ä¸ºè¿›åº¦æ¨¡å‹
  private mapResultToProgress(result: relationalStore.ResultSet): UserProgressModel {
    const progress = new UserProgressModel();
    progress.id = result.getLong(result.getColumnIndex('id'));
    progress.problemId = result.getLong(result.getColumnIndex('problem_id'));
    progress.status = result.getLong(result.getColumnIndex('status')) as ProblemStatus;
    progress.isFavorite = result.getLong(result.getColumnIndex('is_favorite')) === 1;
    progress.lastAttempted = result.getString(result.getColumnIndex('last_attempted')) || '';
    progress.attemptCount = result.getLong(result.getColumnIndex('attempt_count'));
    progress.successCount = result.getLong(result.getColumnIndex('success_count'));
    return progress;
  }

  // è·å–ä»Šæ—¥å®Œæˆçš„é¢˜ç›®è¿›åº¦ï¼ˆåŒ…æ‹¬ç­”å¯¹å’Œç­”é”™ï¼‰
  async getTodayCompletedProgress(): Promise<UserProgressModel[]> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const today = TimeUtils.getLocalDateString(); // YYYY-MM-DDæ ¼å¼
    const sql = 'SELECT * FROM user_progress WHERE (status = ? OR status = ?) AND DATE(last_attempted) = ? ORDER BY last_attempted DESC';
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED, ProblemStatus.WRONG, today]);
    const progressList: UserProgressModel[] = [];

    if (result.rowCount > 0) {
      for (let i = 0; i < result.rowCount; i++) {
        result.goToRow(i);
        const progress = this.mapResultToProgress(result);
        progressList.push(progress);
      }
    }

    return progressList;
  }

  // è·å–å­¦ä¹ æ—¥å†æ•°æ®ï¼ˆæŒ‰æ—¥æœŸåˆ†ç»„çš„å­¦ä¹ è®°å½•ï¼‰
  async getStudyCalendarData(year: number, month: number): Promise<Map<string, number>> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    // è·å–æŒ‡å®šå¹´æœˆçš„å­¦ä¹ è®°å½•
    // æ³¨æ„ï¼šmonthå‚æ•°æ˜¯JavaScript Dateçš„æœˆä»½ï¼ˆ0-11ï¼‰ï¼Œéœ€è¦+1è½¬æ¢ä¸ºå®é™…æœˆä»½
    const actualMonth = month + 1;
    const startDate = `${year}-${String(actualMonth).padStart(2, '0')}-01`;
    
    // è®¡ç®—ä¸‹ä¸ªæœˆçš„å¼€å§‹æ—¥æœŸä½œä¸ºç»“æŸè¾¹ç•Œ
    let nextYear = year;
    let nextMonth = actualMonth + 1;
    if (nextMonth > 12) {
      nextYear = year + 1;
      nextMonth = 1;
    }
    const endDate = `${nextYear}-${String(nextMonth).padStart(2, '0')}-01`;
    
    console.info(`ğŸ“… æŸ¥è¯¢å­¦ä¹ æ•°æ®èŒƒå›´: ${startDate} åˆ° ${endDate}`);
    
    const sql = `
      SELECT SUBSTR(last_attempted, 1, 10) as study_date, COUNT(*) as count
      FROM user_progress 
      WHERE (status = ? OR status = ?) 
        AND last_attempted >= ? 
        AND last_attempted < ?
        AND last_attempted IS NOT NULL
        AND last_attempted != ''
      GROUP BY SUBSTR(last_attempted, 1, 10)
      ORDER BY study_date
    `;
    
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED, ProblemStatus.WRONG, startDate, endDate]);
    const studyMap = new Map<string, number>();

    if (result.rowCount > 0) {
      for (let i = 0; i < result.rowCount; i++) {
        result.goToRow(i);
        const date = result.getString(result.getColumnIndex('study_date'));
        const count = result.getLong(result.getColumnIndex('count'));
        studyMap.set(date, count);
      }
    }

    return studyMap;
  }

  // è·å–æ€»å­¦ä¹ å¤©æ•°
  async getTotalStudyDays(): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const sql = `
      SELECT COUNT(DISTINCT DATE(last_attempted)) as total_days
      FROM user_progress 
      WHERE (status = ? OR status = ?) AND last_attempted IS NOT NULL
    `;
    
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED, ProblemStatus.WRONG]);
    
    if (result.rowCount > 0) {
      result.goToRow(0);
      return result.getLong(result.getColumnIndex('total_days'));
    }

    return 0;
  }

  // æ ¹æ®éš¾åº¦è·å–å®Œæˆæ•°é‡
  async getCompletedCountByDifficulty(difficulty: number): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    // ç”±äºæ•°æ®åº“ä¸­æ²¡æœ‰å­˜å‚¨éš¾åº¦ä¿¡æ¯ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡é¢˜ç›®IDæ¥åˆ¤æ–­
    // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œè¿”å›æ¨¡æ‹Ÿæ•°æ®ï¼Œå®é™…åº”è¯¥å…³è”é¢˜ç›®è¡¨
    const sql = `
      SELECT COUNT(*) as count 
      FROM user_progress 
      WHERE status = ?
    `;
    
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED]);
    
    if (result.rowCount > 0) {
      result.goToRow(0);
      const totalCompleted = result.getLong(result.getColumnIndex('count'));
      // ç®€å•æŒ‰æ¯”ä¾‹åˆ†é…ï¼šç®€å•40%ï¼Œä¸­ç­‰40%ï¼Œå›°éš¾20%
      if (difficulty === 0) return Math.floor(totalCompleted * 0.4);
      if (difficulty === 1) return Math.floor(totalCompleted * 0.4);
      if (difficulty === 2) return Math.floor(totalCompleted * 0.2);
    }

    return 0;
  }

  // è·å–æ€»å®Œæˆé¢˜ç›®æ•°é‡
  async getTotalCompletedProblems(): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    const sql = 'SELECT COUNT(*) as count FROM user_progress WHERE status = ?';
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED]);
    
    if (result.rowCount > 0) {
      result.goToRow(0);
      return result.getLong(result.getColumnIndex('count'));
    }

    return 0;
  }

  // è·å–æ»¡åˆ†æ¬¡æ•°
  async getPerfectScoreCount(): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    // å‡è®¾æ»¡åˆ†æ˜¯æŒ‡ä¸€æ¬¡æ€§å®Œæˆï¼ˆattempt_count = success_count = 1ï¼‰
    const sql = 'SELECT COUNT(*) as count FROM user_progress WHERE status = ? AND attempt_count = 1 AND success_count = 1';
    const result = await store.querySql(sql, [ProblemStatus.COMPLETED]);
    
    if (result.rowCount > 0) {
      result.goToRow(0);
      return result.getLong(result.getColumnIndex('count'));
    }

    return 0;
  }

  // è·å–å·²å®Œæˆåˆ†ç±»æ•°é‡
  async getCompletedCategoriesCount(): Promise<number> {
    const store = this.dbHelper.getStore();
    if (!store) {
      throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');
    }

    // è·å–æ‰€æœ‰åˆ†ç±»çš„é¢˜ç›®
    const allProblems = ProblemMockData.getAllProblems();
    const categorySet = new Set<string>();
    for (const problem of allProblems) {
      categorySet.add(problem.category);
    }
    const categories = Array.from(categorySet);
    let completedCategoriesCount = 0;

    for (const category of categories) {
      const categoryProblems = allProblems.filter(p => p.category === category);
      const categoryProblemIds = categoryProblems.map(p => p.id);
      
      if (categoryProblemIds.length === 0) continue;

      // æ£€æŸ¥è¯¥åˆ†ç±»æ˜¯å¦æœ‰å®Œæˆçš„é¢˜ç›®
      const placeholders = categoryProblemIds.map(() => '?').join(',');
      const sql = `
        SELECT COUNT(*) as count 
        FROM user_progress 
        WHERE status = ? AND problem_id IN (${placeholders})
      `;
      const params = [ProblemStatus.COMPLETED, ...categoryProblemIds];
      const result = await store.querySql(sql, params);
      
      if (result.rowCount > 0) {
        result.goToRow(0);
        const completedCount = result.getLong(result.getColumnIndex('count'));
        if (completedCount > 0) {
          completedCategoriesCount++;
        }
      }
    }

    return completedCategoriesCount;
  }

  // è·å–å¿«é€Ÿè§£é¢˜æ¬¡æ•°ï¼ˆæŒ‡å®šæ—¶é—´å†…å®Œæˆï¼‰
  async getFastSolveCount(maxSeconds: number): Promise<number> {
    // ç”±äºå½“å‰æ•°æ®åº“ç»“æ„æ²¡æœ‰å­˜å‚¨è§£é¢˜æ—¶é—´ï¼Œè¿™é‡Œè¿”å›æ¨¡æ‹Ÿæ•°æ®
    // å®é™…åº”ç”¨ä¸­éœ€è¦åœ¨æ•°æ®åº“ä¸­æ·»åŠ solve_timeå­—æ®µ
    const totalCompleted = await this.getTotalCompletedProblems();
    // å‡è®¾20%çš„é¢˜ç›®æ˜¯å¿«é€Ÿå®Œæˆçš„
    return Math.floor(totalCompleted * 0.2);
  }
}